/**********************************

给定一个 n×n 的整数矩阵。
对任一给定的正整数 k<n，我们将矩阵的偶数列的元素整体向下依次平移 
1、……、k、1、……、k、…… 个位置，平移空出的位置用整数 x 补。你需要计算出结果矩阵的每一行元素的和。

输入格式：
输入第一行给出 3 个正整数：n（<100）、k（<n）、x（<100），分别如题面所述。

接下来 n 行，每行给出 n 个不超过 100 的正整数，为矩阵元素的值。数字间以空格分隔。

输出格式：
在一行中输出平移后第 1 到 n 行元素的和。数字间以 1 个空格分隔，行首尾不得有多余空格。

输入样例：
7 2 99
11 87 23 67 20 75 89
37 94 27 91 63 50 11
44 38 50 26 40 26 24
73 85 63 28 62 18 68
15 83 27 97 88 25 43
23 78 98 20 30 81 99
77 36 48 59 25 34 22

输出样例：
440 399 369 421 302 386 428

样例解读

需要平移的是第 2、4、6 列。
给定 k=2，应该将这三列顺次整体向下平移 1、2、1 位
（如果有更多列，就应该按照 1、2、1、2 …… 这个规律顺次向下平移），顶端的空位用 99 来填充。
平移后的矩阵变成：

11 99 23 99 20 99 89
37 87 27 99 63 75 11
44 94 50 67 40 50 24
73 38 63 91 62 26 68
15 85 27 26 88 18 43
23 83 98 28 30 25 99
77 78 48 97 25 81 22

***********************************/

#include <stdio.h>

int main()
{
    int n, k, x;
    scanf("%d %d %d", &n, &k, &x);
    int a[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a[i][j]);
        }
    }

    for (int j = 1; j < n; j += 2) {
        int move = (j / 2) % 2 == 0 ? 1 : 2;  // 1, 2, 1, 2, ... 交替平移

        // 从底部开始向下平移
        for (int i = n - 1; i >= move; i--) {
            a[i][j] = a[i - move][j];
        }

        // 填充上方的空位
        for (int i = 0; i < move; i++) {
            a[i][j] = x;
        }
    }

    for (int i = 0; i < n; i++) {
        int sum = 0;
        for (int j = 0; j < n; j++) {
            sum += a[i][j];
        }
        if (i == 0) {
            printf("%d", sum);
        } else {
            printf(" %d", sum);
        }
    }
    printf("\n");

    return 0;
}
